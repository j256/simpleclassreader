package com.j256.simpleclassreader;

import java.util.ArrayList;
import java.util.List;

/**
 * Generic access flags that correspond to class, fields, methods, and inner-class attributes.
 * 
 * @author graywatson
 */
public enum AccessFlag {

	/** Declared public; may be accessed from outside its package */
	PUBLIC(0x0001, false, false),
	/** Declared private; accessible only within defining class and other classes belonging to same nest */
	PRIVATE(0x0002, false, false),
	/** Declared protected; may be accessed within subclasses. */
	PROTECTED(0x0004, false, false),
	/** Declared static. */
	STATIC(0x0008, false, false),
	/** Declared final; never directly assigned to after object construction. */
	FINAL(0x0010, false, false),
	/** Declared synchronized; invocation is wrapped by a monitor use. */
	SYNCHRONIZED(0x0020, false, false),
	/** Treat superclass methods specially when invoked by the invoke-special instruction. */
	SUPER(0x0020, false, false),
	/** A bridge method, generated by the compiler. */
	BRIDGE(0x0040, true, false),
	/** Declared volatile; cannot be cached. */
	VOLATILE(0x0040, false, true),
	/** Declared transient; not written or read by a persistent object manager. */
	TRANSIENT(0x0080, false, true),
	/** Declared with variable number of arguments. */
	VARARGS(0x0080, true, false),
	/** Declared native; implemented in a language other than the Java programming language. */
	NATIVE(0x0100, false, false),
	/** Is an interface, not a class. */
	INTERFACE(0x0200, false, false),
	/** Declared abstract; must not be instantiated. */
	ABSTRACT(0x0400, false, false),
	/** Declared strictfp; floating-point mode is FP-strict. */
	STRICT(0x0800, false, false),
	/** Declared synthetic; not present in the source code. */
	SYNTHETIC(0x1000, false, false),
	/** Declared as an annotation type. */
	ANNOTATION(0x2000, false, false),
	/** Declared as an element of an enum. */
	ENUM(0x4000, false, false),
	/** Is a module, not a class or interface. */
	MODULE(0x8000, false, false),
	// end
	;

	private final int bit;
	private final boolean fieldFilter;
	private final boolean methodFilter;

	private AccessFlag(int bit, boolean fieldFilter, boolean methodFilter) {
		this.bit = bit;
		this.fieldFilter = fieldFilter;
		this.methodFilter = methodFilter;
	}

	/**
	 * Return true if the access-flags have this access-info bit set.
	 */
	public boolean isEnabled(int accessFlags) {
		return ((accessFlags & bit) != 0);
	}

	/**
	 * Return the string version of the access-flags.
	 * 
	 * @param accessFlags
	 *            Flags value.
	 * @param fieldFilter
	 *            Set to true to skip the couple flags that overlap with method flags.
	 * @param methodFilter
	 *            Set to true to skip the couple flags that overlap with field flags.
	 */
	public static AccessFlag[] extractFlags(int accessFlags, boolean fieldFilter, boolean methodFilter) {
		List<AccessFlag> flags = new ArrayList<>();
		for (AccessFlag flag : values()) {
			if (fieldFilter && flag.fieldFilter) {
				continue;
			}
			if (methodFilter && flag.methodFilter) {
				continue;
			}
			flags.add(flag);
		}
		return flags.toArray(new AccessFlag[flags.size()]);
	}

	/**
	 * Return the string version of the access-flags.
	 * 
	 * @param accessFlags
	 *            Flags value.
	 * @param fieldFilter
	 *            Set to true to skip the couple flags that overlap with method flags.
	 * @param methodFilter
	 *            Set to true to skip the couple flags that overlap with field flags.
	 */
	public static String flagsToString(int accessFlags, boolean fieldFilter, boolean methodFilter) {
		StringBuilder sb = new StringBuilder();
		sb.append('[');
		for (AccessFlag flag : values()) {
			if (fieldFilter && flag.fieldFilter) {
				continue;
			}
			if (methodFilter && flag.methodFilter) {
				continue;
			}
			if (flag.isEnabled(accessFlags)) {
				if (sb.length() > 1) {
					sb.append(',');
				}
				sb.append(flag);
			}
		}
		sb.append(']');
		return sb.toString();
	}
}
