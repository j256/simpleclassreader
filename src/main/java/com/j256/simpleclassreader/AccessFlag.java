package com.j256.simpleclassreader;

import java.util.ArrayList;
import java.util.List;

/**
 * Generic access flags that correspond to class, fields, methods, and inner-class attributes. There are some
 * overlapping values so all flags have a boolean whether they are class, field, or method only so we can filter them
 * when trying to process flags with the different data types.
 * 
 * @author graywatson
 */
public enum AccessFlag {

	/** Declared public; may be accessed from outside its package */
	PUBLIC(0x0001, false, false, false),
	/** Declared private; accessible only within defining class and other classes belonging to same nest */
	PRIVATE(0x0002, false, false, false),
	/** Declared protected; may be accessed within subclasses. */
	PROTECTED(0x0004, false, false, false),
	/** Declared static. */
	STATIC(0x0008, false, false, false),
	/** Declared final; never directly assigned to after object construction. */
	FINAL(0x0010, false, false, false),
	/** Declared synchronized; invocation is wrapped by a monitor use. */
	SYNCHRONIZED(0x0020, false, false, true),
	/**
	 * Treat superclass methods specially when invoked by the invoke-special instruction.
	 * 
	 * NOTE: this flag is still set for backwards compatibility and does not mean that a class is a super-class.
	 */
	SUPER(0x0020, true, false, false),
	/** A bridge method, generated by the compiler. */
	BRIDGE(0x0040, false, false, true),
	/** Declared volatile; cannot be cached. */
	VOLATILE(0x0040, false, true, false),
	/** Declared transient; not written or read by a persistent object manager. */
	TRANSIENT(0x0080, false, true, false),
	/** Declared with variable number of arguments. */
	VARARGS(0x0080, false, false, true),
	/** Declared native; implemented in a language other than the Java programming language. */
	NATIVE(0x0100, false, false, false),
	/** Is an interface, not a class. */
	INTERFACE(0x0200, false, false, false),
	/** Declared abstract; must not be instantiated. */
	ABSTRACT(0x0400, false, false, false),
	/** Declared strictfp; floating-point mode is FP-strict. */
	STRICT(0x0800, false, false, false),
	/** Declared synthetic; not present in the source code. */
	SYNTHETIC(0x1000, false, false, false),
	/** Declared as an annotation type. */
	ANNOTATION(0x2000, false, false, false),
	/** Declared as an element of an enum. */
	ENUM(0x4000, false, false, false),
	/** Is a module, not a class or interface. */
	MODULE(0x8000, false, false, false),
	// end
	;

	private final int bit;
	private final boolean classOnly;
	private final boolean fieldOnly;
	private final boolean methodOnly;

	private AccessFlag(int bit, boolean classOnly, boolean fieldOnly, boolean methodOnly) {
		this.bit = bit;
		this.classOnly = classOnly;
		this.fieldOnly = fieldOnly;
		this.methodOnly = methodOnly;
	}

	/**
	 * Return true if the access-flags have this access-info bit set.
	 */
	public boolean isEnabled(int accessFlags) {
		return ((accessFlags & bit) != 0);
	}

	/**
	 * Return the string version of the access-flags.
	 * 
	 * @param accessFlags
	 *            Flags value.
	 * @param classOnly
	 *            Set to true to skip the couple flags that aren't class flags.
	 * @param fieldOnly
	 *            Set to true to skip the couple flags that aren't field flags;.
	 * @param methodOnly
	 *            Set to true to skip the couple flags that aren't method flags.
	 */
	public static AccessFlag[] extractFlags(int accessFlags, boolean classOnly, boolean fieldOnly, boolean methodOnly) {
		List<AccessFlag> flags = new ArrayList<>();
		for (AccessFlag flag : values()) {
			if (classOnly && (flag.fieldOnly || flag.methodOnly)) {
				continue;
			}
			if (fieldOnly && (flag.classOnly || flag.methodOnly)) {
				continue;
			}
			if (methodOnly && (flag.classOnly || flag.fieldOnly)) {
				continue;
			}
			if (flag.isEnabled(accessFlags)) {
				flags.add(flag);
			}
		}
		return flags.toArray(new AccessFlag[flags.size()]);
	}

	/**
	 * Return the string version of the access-flags.
	 * 
	 * @param accessFlags
	 *            Flags value.
	 * @param classOnly
	 *            Set to true to skip the couple flags that aren't class flags.
	 * @param fieldOnly
	 *            Set to true to skip the couple flags that aren't field flags.
	 * @param methodOnly
	 *            Set to true to skip the couple flags that aren't method flags.
	 */
	public static String flagsToString(int accessFlags, boolean classOnly, boolean fieldOnly, boolean methodOnly) {
		StringBuilder sb = new StringBuilder();
		sb.append('[');
		for (AccessFlag flag : values()) {
			if (classOnly && (flag.fieldOnly || flag.methodOnly)) {
				continue;
			}
			if (fieldOnly && (flag.classOnly || flag.methodOnly)) {
				continue;
			}
			if (methodOnly && (flag.classOnly || flag.fieldOnly)) {
				continue;
			}
			if (flag.isEnabled(accessFlags)) {
				if (sb.length() > 1) {
					sb.append(',');
				}
				sb.append(flag);
			}
		}
		sb.append(']');
		return sb.toString();
	}
}
