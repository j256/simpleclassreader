package com.j256.simpleclassreader;

import java.io.DataInputStream;
import java.io.IOException;

/**
 * Information about a field that the class has.
 * 
 * @author graywatson
 */
public class MethodInfo {

	private final int accessFlags;
	private final String name;
	private final MethodDescriptor methodDescriptor;
	private final AttributeInfo[] attributes;

	public MethodInfo(int accessFlags, String name, MethodDescriptor methodDescriptor, AttributeInfo[] attributes) {
		this.accessFlags = accessFlags;
		this.name = name;
		this.methodDescriptor = methodDescriptor;
		this.attributes = attributes;
	}

	public int getAccessFlags() {
		return accessFlags;
	}

	/**
	 * Declared private; accessible only within defining class and other classes belonging to same nest
	 */
	public boolean isPublic() {
		return MethodAccessInfo.PUBLIC.isEnabled(accessFlags);
	}

	public boolean isPrivate() {
		return MethodAccessInfo.PRIVATE.isEnabled(accessFlags);
	}

	public boolean isProtected() {
		return MethodAccessInfo.PROTECTED.isEnabled(accessFlags);
	}

	public boolean isStatic() {
		return MethodAccessInfo.STATIC.isEnabled(accessFlags);
	}

	public boolean isFinal() {
		return MethodAccessInfo.FINAL.isEnabled(accessFlags);
	}

	public boolean isSynchronized() {
		return MethodAccessInfo.SYNCHRONIZED.isEnabled(accessFlags);
	}

	public boolean isBridge() {
		return MethodAccessInfo.BRIDGE.isEnabled(accessFlags);
	}

	public boolean isVerargs() {
		return MethodAccessInfo.VARARGS.isEnabled(accessFlags);
	}

	/**
	 * Declared native; implemented in a language other than the Java programming language.
	 */
	public boolean isNative() {
		return MethodAccessInfo.NATIVE.isEnabled(accessFlags);
	}

	public boolean isAbstract() {
		return MethodAccessInfo.ABSTRACT.isEnabled(accessFlags);
	}

	public boolean isStrict() {
		return MethodAccessInfo.STRICT.isEnabled(accessFlags);
	}

	public boolean isSynthetic() {
		return MethodAccessInfo.SYNTHETIC.isEnabled(accessFlags);
	}

	public String getName() {
		return name;
	}

	public MethodDescriptor getMethodDescriptor() {
		return methodDescriptor;
	}

	public AttributeInfo[] getAttributes() {
		return attributes;
	}

	/**
	 * Read in a field information entry.
	 */
	public static MethodInfo read(ClassReader reader, DataInputStream dis) throws IOException {
		// u2 access_flags;
		// u2 name_index;
		// u2 descriptor_index;
		// u2 attributes_count;
		// attribute_info attributes[attributes_count];

		int accessFlags = dis.readUnsignedShort();
		int index = dis.readUnsignedShort();
		String name = reader.findName(index, ClassReaderError.INVALID_METHOD_NAME_INDEX);
		index = dis.readUnsignedShort();
		String methodDescriptorStr = reader.findName(index, ClassReaderError.INVALID_METHOD_DESCRIPTOR_INDEX);
		MethodDescriptor methodDescriptor = null;
		if (methodDescriptorStr != null) {
			methodDescriptor = MethodDescriptor.fromString(methodDescriptorStr);
		}
		int attributeCount = dis.readUnsignedShort();
		AttributeInfo[] attributes = new AttributeInfo[attributeCount];
		for (int i = 0; i < attributeCount; i++) {
			attributes[i] = AttributeInfo.read(reader, dis);
		}

		return new MethodInfo(accessFlags, name, methodDescriptor, attributes);
	}

	/**
	 * Access information associated with a field.
	 */
	private static enum MethodAccessInfo {
		/** Declared public; may be accessed from outside its package */
		PUBLIC(0x0001),
		/** Declared private; accessible only within defining class and other classes belonging to same nest */
		PRIVATE(0x0002),
		/** Declared protected; may be accessed within subclasses. */
		PROTECTED(0x0004),
		/** Declared static. */
		STATIC(0x0008),
		/** Declared final; must not be overridden */
		FINAL(0x0010),
		/** Declared synchronized; invocation is wrapped by a monitor use. */
		SYNCHRONIZED(0x0020),
		/** A bridge method, generated by the compiler. */
		BRIDGE(0x0040),
		/** Declared with variable number of arguments. */
		VARARGS(0x0080),
		/** Declared native; implemented in a language other than the Java programming language. */
		NATIVE(0x0100),
		/** Declared abstract; no implementation is provided. */
		ABSTRACT(0x0100),
		/** Declared strictfp; floating-point mode is FP-strict. */
		STRICT(0x0800),
		/** Declared synthetic; not present in the source code. */
		SYNTHETIC(0x1000),
		// end
		;

		private final int bit;

		private MethodAccessInfo(int bit) {
			this.bit = bit;
		}

		/**
		 * Return true if the access-flags have this access-info bit set.
		 */
		public boolean isEnabled(int accessFlags) {
			return ((accessFlags & bit) != 0);
		}
	}
}
